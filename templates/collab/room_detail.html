{% extends "base.html" %}
{% load static %}
{% block title %}{{ room.Romname }} Â· CodingLine{% endblock %}
{% block content %}

<link rel="stylesheet" href="{% static 'css/room_detail2.css' %}">

<h1 id="room-title" class="head__title">{{ room.Romname }}</h1>
<p id="room-topic" class="head__desc">ì£¼ì œ: {{ room.topic }}</p>

{% comment %} {% if request.user.is_authenticated and request.user.pk == room.created_by_id %}
<div class="mb-3" style="display:flex; gap:8px; align-items:center;">
  <button id="btn-room-edit" class="btn">ìˆ˜ì •í•˜ê¸°</button>
  <form method="post" action="{% url 'api-room-delete' room.slug %}"
        onsubmit="return confirm('ì •ë§ ì´ ë°©ì„ ì‚­ì œí• ê¹Œìš”? ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');">
    {% csrf_token %}
    <button type="submit" class="btn" style="color:#ff6b6b; border-color:#b4232a;">ë°© ì‚­ì œ</button>
  </form>
</div> {% endcomment %}
<div class="mb-3 owner-only" style="display:none; gap:8px; align-items:center;">
  <button id="btn-room-edit" class="btn">ìˆ˜ì •í•˜ê¸°</button>
  <form method="post" action="{% url 'api-room-delete' room.slug %}"
        onsubmit="return confirm('ì •ë§ ì´ ë°©ì„ ì‚­ì œí• ê¹Œìš”? ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');">
    {% csrf_token %}
    <button type="submit" class="btn" style="color:#ff6b6b; border-color:#b4232a;">ë°© ì‚­ì œ</button>
  </form>
</div>

<div id="room-edit-panel" class="card hidden owner-only" style="display:none;">
  <h3 class="card__title">ë°© ì •ë³´ ìˆ˜ì •</h3>
  <div class="form" style="display:grid; gap:12px; grid-template-columns:repeat(2,minmax(0,1fr));">
    <label class="field">
      <span class="field__label">ë°© ì œëª©</span>
      <input id="edit-name" type="text" value="{{ room.Romname }}" class="search__input" />
    </label>
    <label class="field">
      <span class="field__label">ì£¼ì œ</span>
      <input id="edit-topic" type="text" value="{{ room.topic }}" class="search__input" />
    </label>
    <label class="field">
      <span class="field__label">ë¹„ë°€ë²ˆí˜¸(ë¹ˆì¹¸=í•´ì œ)</span>
      <input id="edit-password" type="text" value="{{ room.password }}" class="search__input" />
    </label>
    <label class="field">
      <span class="field__label">ì •ì›(1~500)</span>
      <input id="edit-capacity" type="number" min="1" max="500" value="{{ room.capacity }}" class="search__input" />
    </label>
  </div>
  <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
    <button id="btn-room-save" class="btn">ì €ì¥</button>
    <button id="btn-room-cancel" class="btn">ì·¨ì†Œ</button>
    <span id="edit-error" class="muted hidden">ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.</span>
  </div>
</div>

<form id="room-leave" action="{% url 'room-leave' room.slug %}" method="post" class="mb-4">
  {% csrf_token %}
  <button class="btn" id="btn-leave">ë°© ë‚˜ê°€ê¸°</button>
</form>

<div class="room-layout">
  <!-- â¬… ì´ë¯¸ì§€ ë·°ì–´ -->
  <section id="image-viewer" class="image-viewer">
    <div id="image-empty" class="image-viewer__empty">ì•„ì§ ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.</div>
    <img id="image-current" class="image-viewer__img" alt="uploaded image" />
    <button id="image-prev" class="image-viewer__nav image-viewer__nav--prev">ì´ì „</button>
    <button id="image-next" class="image-viewer__nav image-viewer__nav--next">ë‹¤ìŒ</button>
    <div id="image-indicator" class="image-viewer__ind">1 / 1</div>

    <!-- ğŸ¨ ë“œë¡œì‰ íˆ´ë°” -->
    <div id="draw-toolbar" class="draw__toolbar hidden">
      <label class="draw__label">íœ
        <input type="color" id="pen-color" value="#111111" />
      </label>
      <label class="draw__label">êµµê¸°
        <input type="range" id="pen-size" min="1" max="40" value="4" />
      </label>
      <button type="button" id="btn-draw-toggle" class="draw__btn">ê·¸ë¦¬ê¸° ì¼œê¸°</button>
      <button type="button" id="btn-pen" class="draw__btn">íœ</button>
      <button type="button" id="btn-eraser" class="draw__btn">ì§€ìš°ê°œ</button>
      <button type="button" id="btn-clear" class="draw__btn">ì§€ìš°ê¸°</button>
      <button type="button" id="btn-download" class="draw__btn">ë‹¤ìš´ë¡œë“œ</button>
      <button type="button" id="btn-imgdelete" class="draw__btn">ì´ë¯¸ì§€ì‚­ì œ</button>
    </div>

    <canvas id="draw-canvas" class="draw__canvas hidden"></canvas>
  </section>

  <!-- â¡ ì‚¬ì´ë“œë°” -->
  <aside class="sidebar">
    <section class="card">
      <h3 class="text-sm font-semibold" style="margin-bottom:8px;">ì ‘ì†ì</h3>
      <ul id="online-list" class="online__list"></ul>
    </section>

    {% comment %} {% if request.user.is_authenticated and request.user.pk == room.created_by_id %}
    <section id="pending-panel" class="card">
      <h3 class="text-sm font-semibold" style="margin-bottom:8px;">ìŠ¹ì¸ ëŒ€ê¸° ì´ë¯¸ì§€</h3>
      <ul id="pending-list" style="display:flex; flex-direction:column; gap:8px;"></ul>
      <p id="pending-empty" class="muted">ëŒ€ê¸° í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤.</p>
    </section>
    {% endif %} {% endcomment %}
    <section id="pending-panel" class="card owner-only" style="display:none;">
      <h3 class="text-sm font-semibold" style="margin-bottom:8px;">ìŠ¹ì¸ ëŒ€ê¸° ì´ë¯¸ì§€</h3>
      <ul id="pending-list" style="display:flex; flex-direction:column; gap:8px;"></ul>
      <p id="pending-empty" class="muted">ëŒ€ê¸° í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤.</p>
    </section>

    <section class="card chat">
      <header class="chat__head">ì±„íŒ…</header>
      <div id="chat-log" class="chat__log" data-page-loaded="0"></div>
      <footer class="chat__foot">
        <form id="chat-form" class="chat__form">
          <input id="chat-input" type="text" class="chat__input" placeholder="ë©”ì‹œì§€ ì…ë ¥â€¦" />
          <button class="chat__send">ì „ì†¡</button>
        </form>
      </footer>
    </section>

    <section class="card">
      <h3 class="text-sm font-semibold" style="margin-bottom:8px;">ì´ë¯¸ì§€ ì—…ë¡œë“œ</h3>
      <form id="upload-form" class="upload__form">
        <input id="image-input" type="file" accept="image/*" multiple class="upload__input" />
        <button class="upload__btn">ì—…ë¡œë“œ</button>
      </form>
      <p class="muted text-xs" style="margin-top:6px;">â€» ì—…ë¡œë“œëŠ” ë°©ì¥ ìŠ¹ì¸ í›„ ì „ì²´ì— í‘œì‹œë©ë‹ˆë‹¤.</p>
    </section>
  </aside>
</div>

<script>
(function(){
  const slug = "{{ room.slug }}";
  const scheme = location.protocol === "https:" ? "wss" : "ws";
  const wsUrl = `${scheme}://${location.host}/ws/rooms/${slug}/`;
  const csrftoken = document.querySelector('input[name="csrfmiddlewaretoken"]')?.value || "";
  const HOME_URL = "{% url 'home' %}";

  const ME_ID    = {{ request.user.id|default:"null" }};
  const OWNER_ID = {{ room.created_by_id|default:"null" }};
  let I_AM_OWNER = (ME_ID !== null && OWNER_ID !== null && ME_ID === OWNER_ID);

  const $chatLog   = document.getElementById('chat-log');
  const $chatForm  = document.getElementById('chat-form');
  const $chatInput = document.getElementById('chat-input');
  const $uploadForm= document.getElementById('upload-form');
  const $imageInput= document.getElementById('image-input');
  const $online    = document.getElementById('online-list');

  const $img      = document.getElementById('image-current');
  const $imgEmpty = document.getElementById('image-empty');
  const $imgPrev  = document.getElementById('image-prev');
  const $imgNext  = document.getElementById('image-next');
  const $imgInd   = document.getElementById('image-indicator');
  const $viewer   = document.getElementById('image-viewer');

  const $canvas  = document.getElementById('draw-canvas');
  const $toolbar = document.getElementById('draw-toolbar');
  const $pen     = document.getElementById('btn-pen');
  const $eraser  = document.getElementById('btn-eraser');
  const $clear   = document.getElementById('btn-clear');
  const $toggle  = document.getElementById('btn-draw-toggle');
  const $dl      = document.getElementById('btn-download');
  const $del_btn = document.getElementById('btn-imgdelete');

  const $penColor= document.getElementById('pen-color');
  const $penSize = document.getElementById('pen-size');
  const ctx = $canvas.getContext('2d');

  // === ë””ë²„ê·¸ & ì‰¬ìš´ ëª¨ë“œ ìŠ¤ìœ„ì¹˜ ===
  let DRAW_DEBUG = true;                 // ì½˜ì†” ë¡œê·¸ ì¼œê¸°/ë„ê¸°
  let EASY_MODE_IGNORE_IMAGE_ID = false; // trueë©´ image_id ë¬´ì‹œ(ë””ë²„ê·¸ìš©)
  let EASY_MODE_INDEX_FALLBACK = true;   // trueë©´ id ì•ˆ ë§ì•„ë„ ì¸ë±ìŠ¤ ê°™ìœ¼ë©´ í—ˆìš©
  function logD(...args){ if (DRAW_DEBUG) console.log("[draw]", ...args); }
  function warnD(...args){ if (DRAW_DEBUG) console.warn("[draw âš ]", ...args); }
  function errD(...args){ if (DRAW_DEBUG) console.error("[draw â›”]", ...args); }
  function groupD(label, fn){ if (!DRAW_DEBUG){ try{ fn(); }catch(e){} return; } console.groupCollapsed(`[draw] ${label}`); try{ fn(); } finally { console.groupEnd(); } }
  window.__drawFlags = { get: () => ({ DRAW_DEBUG, EASY_MODE_IGNORE_IMAGE_ID, EASY_MODE_INDEX_FALLBACK }), set: (k,v)=>{ if (k==='DRAW_DEBUG') DRAW_DEBUG=!!v; if (k==='EASY_MODE_IGNORE_IMAGE_ID') EASY_MODE_IGNORE_IMAGE_ID=!!v; if (k==='EASY_MODE_INDEX_FALLBACK') EASY_MODE_INDEX_FALLBACK=!!v; } };

  // A+Bìš© ìƒíƒœ
  let lastSentPoint = null;        // ì „ì†¡ ë§ˆì§€ë§‰ ì (ì†¡ì‹ )
  let currentPathId = null;        // í•œ ë¶“ì§ˆ id(ì†¡ì‹ )
  const remotePaths = new Map();   // path_idë³„ ë§ˆì§€ë§‰ ì (ìˆ˜ì‹ )

  // ì—…ë¡œë” ì „ìš© ë³´ê´€
  const localPendingFiles = new Map();
  // ë°©ì¥ ëŒ€ê¸° í
  const pendingQueue = new Map();

  // ìœ í‹¸
  function el(tag, attrs = {}, ...children) {
    const n = document.createElement(tag);
    Object.entries(attrs).forEach(([k, v]) => v != null && (k==='class'? (n.className=v) : n.setAttribute(k, v)));
    children.forEach(c => n.appendChild(typeof c === 'string' ? document.createTextNode(c) : c));
    return n;
  }
  function show(el, display='block'){ el?.classList.remove('hidden'); el.style.display = display; }
  function hide(el){ el?.classList.add('hidden'); el.style.display = 'none'; }
  function fmtBytes(n){ if(!n&&n!==0)return ''; const u=['B','KB','MB','GB']; let i=0,v=n; while(v>=1024&&i<u.length-1){v/=1024;i++;} return `${v.toFixed(v<10&&i?1:0)} ${u[i]}`;}

  // ì´ë¯¸ì§€ í‚¤ ì •ê·œí™”
  function getImageKey(img){
   const v = (img?.id) ?? (img?.image_id) ?? (img?.message_id) ?? (img?.image_url) ?? null;
   return v == null ? null : String(v); // âœ… í•­ìƒ ë¬¸ìì—´ë¡œ
 }

  // ì ‘ì†ì
  const state = {version:0, users:new Map()};
  function renderUserItem(user){
    const id = `user-${user.user_id}`;
    const label = user.username + (user.is_owner ? " (ë°©ì¥)" : "");
    const row = el("li", {id, class:"online__item"}, el("span",{}, label));
    const old = document.getElementById(id);
    if (old) old.replaceWith(row); else $online.appendChild(row);
  }
  function removeUserItem(userId){ document.getElementById(`user-${userId}`)?.remove(); }
  function reconcileUsersFromSnapshot(ss){
    if (typeof ss.version === "number" && ss.version < state.version) return;
    if (typeof ss.version === "number") state.version = ss.version;
    const incoming = ss.members || [];
    const ids = new Set(incoming.map(u=>u.user_id));
    for(const u of incoming){ state.users.set(u.user_id, u); renderUserItem(u); }
    for(const id of Array.from(state.users.keys())){ if(!ids.has(id)){ state.users.delete(id); removeUserItem(id); } }
  }

  // ì±„íŒ…
  function appendChat({user,message,ts}){
    const time = new Date(ts).toLocaleTimeString();
    const row = el('div', {class:'text-sm'},
      el('span',{class:'font-medium'},user),' : ',
      el('span',{},message),
      el('span',{class:'text-[11px] text-gray-500 ml-2'},time)
    );
    $chatLog.appendChild(row);
    $chatLog.scrollTop = $chatLog.scrollHeight;
  }

  // ì´ë¯¸ì§€ ë¦¬ìŠ¤íŠ¸/ë·°ì–´
  const imageState = { list:[], idx:-1 }; // {id,user,image_url,ts,overlay?}

  function renderImageViewer(){
    const n = imageState.list.length;
    if (n === 0){
      hide($img); show($imgEmpty);
      hide($imgPrev); hide($imgNext); hide($imgInd);
      hide($canvas); hide($toolbar);
      imageState.idx = -1;
      return;
    }
    if (imageState.idx < 0) imageState.idx = 0;
    if (imageState.idx > n-1) imageState.idx = n-1;

    const cur = imageState.list[imageState.idx];
    hide($imgEmpty); show($img, 'block');

    if (n > 1){
      show($imgPrev,'inline-flex'); show($imgNext,'inline-flex');
      $imgInd.textContent = `${imageState.idx+1} / ${n}`; show($imgInd, 'block');
    } else {
      hide($imgPrev); hide($imgNext); hide($imgInd);
    }

    groupD("renderImageViewer", () => {
      logD("list.len", imageState.list.length, "idx", imageState.idx, "key", getImageKey(cur), "url", cur?.image_url);
    });

    const afterLoad = () => {
      resizeCanvasToImage();
      const hasKey = !!getImageKey(cur);
      if (hasKey) { show($canvas,'block'); show($toolbar,'flex'); }
      else { hide($canvas); hide($toolbar); }
      restoreOverlayForCurrentImage();

      if (ws?.readyState === 1 && cur && getImageKey(cur)) {
        ws.send(JSON.stringify({ action:'draw.request_snapshot', image_id: getImageKey(cur) }));
      }
    };

    if ($img.src === cur.image_url && $img.complete) afterLoad();
    else {
      $img.onload = () => { $img.onload = null; afterLoad(); };
      $img.src = cur.image_url;
    }
  }

  function pushImageMessage(msg, jumpToLatest=true){
    msg.id = msg.id || msg.image_id || msg.message_id || msg.image_url || null;
    const i = imageState.list.findIndex(it => getImageKey(it) === getImageKey(msg));
    if (i >= 0) imageState.list[i] = msg;
    else {
      imageState.list.push(msg);
      imageState.list.sort((a,b) => new Date(a.ts) - new Date(b.ts));
    }
    if (jumpToLatest) imageState.idx = imageState.list.length-1;
    else if (imageState.idx === -1) imageState.idx = 0;
    renderImageViewer();
    restoreOverlayForCurrentImage();
  }

  // ë“œë¡œì‰/ìº”ë²„ìŠ¤
  const drawState = { enabled:false, drawing:false, mode:'pen', color:'#111111', size:4, dpr:devicePixelRatio||1 };
  function resizeCanvasToImage(){
    const imgRect = $img.getBoundingClientRect();
    const viewRect= $viewer.getBoundingClientRect();
    const left=imgRect.left-viewRect.left, top=imgRect.top-viewRect.top, w=imgRect.width, h=imgRect.height;
    Object.assign($canvas.style, {left:left+'px', top:top+'px', width:w+'px', height:h+'px'});
    const s = drawState.dpr;
    $canvas.width = Math.max(1, Math.floor(w*s));
    $canvas.height= Math.max(1, Math.floor(h*s));
    ctx.setTransform(s,0,0,s,0,0);
  }
  function persistOverlayForCurrentImage(){
    if (imageState.idx < 0) return;
    try { imageState.list[imageState.idx].overlay = $canvas.toDataURL('image/png'); } catch {}
  }
  function restoreOverlayForCurrentImage(){
    ctx.clearRect(0,0,$canvas.width,$canvas.height);
    if (imageState.idx < 0) return;
    const cur = imageState.list[imageState.idx];
    if (cur?.overlay){
      const im = new Image();
      im.onload = () => ctx.drawImage(im, 0,0,$canvas.clientWidth,$canvas.clientHeight);
      im.src = cur.overlay;
    }
  }
  function getOffsetInCanvas(e){
    const r = $canvas.getBoundingClientRect();
    const x = (e.clientX ?? (e.touches?.[0]?.clientX || 0)) - r.left;
    const y = (e.clientY ?? (e.touches?.[0]?.clientY || 0)) - r.top;
    return {x,y};
  }
  function applyBrush(){
    ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.lineWidth = Number(drawState.size);
    if (drawState.mode==='pen'){ ctx.globalCompositeOperation='source-over'; ctx.strokeStyle=drawState.color; }
    else { ctx.globalCompositeOperation='destination-out'; ctx.strokeStyle='rgba(0,0,0,1)'; }
  }

  // ì •ê·œí™” <-> í™”ë©´
  function getImageBox(){
    const a = $img.getBoundingClientRect(), b=$viewer.getBoundingClientRect();
    return { left:a.left-b.left, top:a.top-b.top, width:a.width, height:a.height };
  }
  function toNormalizedPoint(x,y){ const b=getImageBox(); return {x:(x-b.left)/Math.max(1,b.width), y:(y-b.top)/Math.max(1,b.height)}; }
  function fromNormalizedPoint(nx,ny){ const b=getImageBox(); return {x: b.left+nx*b.width, y:b.top+ny*b.height}; }

  // ì „ì†¡ ë°°ì¹˜
  let sendTimer = null, queuedPoints = [];

  function sendStrokeChunk(points, first=false, last=false){
    if (!ws || ws.readyState !== 1 || imageState.idx<0 || !points.length) return;
    const cur = imageState.list[imageState.idx];
    const imageKey = getImageKey(cur);
    if (!imageKey) { warnD("no imageKey; skip send"); return; }

    // ì—°ì†ì„± ë³´ì¥
    let payloadPts = points;
    if (!first && lastSentPoint) payloadPts = [lastSentPoint, ...points];

    const norm = payloadPts.map(p => {
      const np = toNormalizedPoint(p.x,p.y);
      return {x:np.x, y:np.y};
    });

    groupD("sendStrokeChunk", () => {
      logD({ first, last, path_id: currentPathId, image_id: imageKey, image_idx: imageState.idx, pts: payloadPts.length, wsReady: ws.readyState });
    });

    ws.send(JSON.stringify({
      action: 'draw.stroke',
      image_id: String(imageKey),
      image_idx: imageState.idx, // ì¸ë±ìŠ¤ë„ í•¨ê»˜
      path_id: currentPathId || `${ME_ID||'anon'}_${Date.now()}`,
      points: norm,
      color: drawState.color,
      size: drawState.size,
      mode: drawState.mode,
      first, last,
      ts: Date.now()
    }));

    lastSentPoint = payloadPts[payloadPts.length - 1];
  }

  function beginStroke(e){
    if (!drawState.enabled) { warnD("beginStroke ignored: draw disabled"); return; }
    drawState.drawing = true;
    currentPathId = (window.crypto?.randomUUID?.() 
    || `${ME_ID||'anon'}-${Date.now()}-${Math.random().toString(36).slice(2)}`); // ë¶“ì§ˆ id
    lastSentPoint = null;                             // ìŠ¤íŠ¸ë¡œí¬ ì‹œì‘ ë¦¬ì…‹
    applyBrush();

    const {x,y} = getOffsetInCanvas(e);
    ctx.beginPath();
    ctx.moveTo(x,y);

    logD("beginStroke", { path_id: currentPathId, start: {x,y}, image_idx: imageState.idx, image_id: getImageKey(imageState.list[imageState.idx]) });

    sendStrokeChunk([{x,y}], true, false);
  }

  function drawStroke(e){
    if (!drawState.enabled || !drawState.drawing) return;
    const {x,y} = getOffsetInCanvas(e);
    ctx.lineTo(x,y); ctx.stroke();
    queuedPoints.push({x,y});
    if (!sendTimer){
      sendTimer = setTimeout(()=>{ const chunk=queuedPoints.splice(0); logD("drawStroke flush", { count: chunk.length }); sendStrokeChunk(chunk,false,false); sendTimer=null; },16);
    }
  }
  function endStroke(){
    if (!drawState.drawing) return;
    drawState.drawing = false;

    logD("endStroke", { queued: queuedPoints.length, lastSentPoint: !!lastSentPoint });

    if (queuedPoints.length){
      const chunk = queuedPoints.splice(0);
      sendStrokeChunk(chunk, false, true);  // last=trueë¡œ ì¢…ë£Œ ì•Œë¦¼
    } else if (lastSentPoint) {
      sendStrokeChunk([lastSentPoint], false, true);
    }

    lastSentPoint = null;  // ìŠ¤íŠ¸ë¡œí¬ ì¢…ë£Œ í›„ ë¦¬ì…‹
  }

  $canvas.addEventListener('pointerdown', e=>{applyBrush();beginStroke(e);});
  $canvas.addEventListener('pointermove', drawStroke);
  window.addEventListener('pointerup', endStroke);
  $canvas.addEventListener('pointerleave', endStroke);
  $canvas.addEventListener('touchstart', e=>e.preventDefault(), {passive:false});

  // íˆ´ë°”
  $toggle.addEventListener('click', ()=>{ drawState.enabled=!drawState.enabled; $toggle.textContent = drawState.enabled?'ê·¸ë¦¬ê¸° ë„ê¸°':'ê·¸ë¦¬ê¸° ì¼œê¸°'; });
  $pen.addEventListener('click', ()=>{ drawState.mode='pen'; });
  $eraser.addEventListener('click', ()=>{ drawState.mode='eraser'; });
  $penColor.addEventListener('input', e=>{ drawState.color=e.target.value||'#111111'; });
  $penSize.addEventListener('input', e=>{ drawState.size=Number(e.target.value||4); });
  $clear.addEventListener('click', ()=>{
    ctx.clearRect(0,0,$canvas.width,$canvas.height);
    if (imageState.idx>=0){ const cur=imageState.list[imageState.idx]; if(cur) cur.overlay=null; }
    if (ws?.readyState===1 && imageState.idx>=0){
      const cur=imageState.list[imageState.idx];
      const imageKey = getImageKey(cur);
      if (imageKey) ws.send(JSON.stringify({ action:'draw.clear', image_id: String(imageKey), ts:Date.now() }));
    }
  });

  $dl.addEventListener('click', async ()=>{
    if (imageState.idx<0) return;
    const w=$canvas.clientWidth, h=$canvas.clientHeight, s=drawState.dpr;
    const t=document.createElement('canvas'); t.width=w*s; t.height=h*s; const tctx=t.getContext('2d'); tctx.setTransform(s,0,0,s,0,0);
    await new Promise(r=>{ const base=new Image(); base.crossOrigin='anonymous'; base.onload=()=>{tctx.drawImage($img,0,0,w,h); r();}; base.src=$img.src; if(base.complete) r(); });
    const ovURL=$canvas.toDataURL('image/png');
    await new Promise(r=>{ const ov=new Image(); ov.onload=()=>{tctx.drawImage(ov,0,0,w,h); r();}; ov.src=ovURL; if(ov.complete) r(); });
    const a=document.createElement('a'); const cur=imageState.list[imageState.idx];
    a.href=t.toDataURL('image/png'); a.download=`annotated_${getImageKey(cur)||Date.now()}.png`; a.click();
  });

  // ë¦¬ì‚¬ì´ì¦ˆ
  window.addEventListener('resize', ()=>{
    if ($img && !$img.classList.contains('hidden') && imageState.idx>=0){
      persistOverlayForCurrentImage(); resizeCanvasToImage(); restoreOverlayForCurrentImage();
    }
  });

  // ì±„íŒ… íˆìŠ¤í† ë¦¬ (í•„ìš”ì‹œ ìœ ì§€)
  let chatPage=0, chatMaxPages=null, chatLoading=false;
  async function loadOlderMessages(){
    if(chatLoading) return;
    if(chatMaxPages!==null && chatPage>=chatMaxPages) return;
    chatLoading=true;
    try{
      const nextPage = chatPage+1;
      const res = await fetch(`/rooms/${slug}/messages/?page=${nextPage}`);
      if(!res.ok) return;
      const data = await res.json();
      const oldH=$chatLog.scrollHeight, oldT=$chatLog.scrollTop;
      const items=(data.results||[]).slice().reverse();
      for(const m of items){
        if (m.image_url){
          appendChat({user:m.user||'user', message:'[ì´ë¯¸ì§€ ì—…ë¡œë“œ]', ts:m.ts});
          logD("history image", { image_id: m.image_id, message_id: m.id||m.message_id, image_url: m.image_url });
          pushImageMessage({id: m.image_id || m.id || m.message_id || m.image_url || null, image_id:m.image_id, message_id:m.message_id, user:m.user, image_url:m.image_url, ts:m.ts}, false);
        } else {
          appendChat({user:m.user, message:m.content, ts:m.ts});
        }
      }
      chatPage = data.page || nextPage;
      chatMaxPages = data.num_pages ?? chatMaxPages;
      const newH=$chatLog.scrollHeight; $chatLog.scrollTop = newH - (oldH - oldT);
    } finally { chatLoading=false; }
  }
  document.addEventListener('DOMContentLoaded', async()=>{ await loadOlderMessages(); $chatLog.scrollTop=$chatLog.scrollHeight; });
  $chatLog.addEventListener('scroll', ()=>{ if ($chatLog.scrollTop<=40) loadOlderMessages(); });

  // WebSocket
  let ws;
  function connect(){
    ws = new WebSocket(wsUrl);
    ws.onopen = () => {
      logD("ws open", { url: wsUrl, readyState: ws.readyState });
      if (imageState.list.length>0 && imageState.idx>=0){
        const img = imageState.list[imageState.idx];
        ws.send(JSON.stringify({ action:'image.goto', idx:imageState.idx, image_id:String(getImageKey(img)), ts:Date.now() }));
      }
    };
    ws.onerror = (e) => { errD("ws error", e); };
    ws.onmessage = (e) => {
      let data; try{ data=JSON.parse(e.data);}catch{return;}

      switch (data.event){
        case "presence_snapshot": reconcileUsersFromSnapshot(data); break;
        case "room.updated":
          if (data.name)  document.getElementById('room-title').textContent = data.name;
          if (data.topic) document.getElementById('room-topic').textContent = `ì£¼ì œ: ${data.topic}`;
          break;
        case "room.deleted":
          try{ localStorage.setItem('last_toast', JSON.stringify({level:'warning', text:data.msg||'ë°©ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.'})); }catch{}
          try{ ws.close(4404);}catch{}
          break;
        case "chat":
          appendChat({user:data.user, message:data.message, ts:data.ts}); break;
        case "image":
          groupD("recv image event", () => logD({ image_id: data.image_id, message_id: data.message_id, image_url: data.image_url }));
          appendChat({user:data.user||data.sender||'user', message:'[ì´ë¯¸ì§€ ì—…ë¡œë“œ]', ts:data.ts});
          pushImageMessage({
            id: data.image_id || data.message_id || data.image_url || null,
            image_id: data.image_id,
            message_id: data.message_id,
            user: data.user || data.sender,
            image_url: data.image_url,
            ts: data.ts
          }, true);
          break;
        case "user_joined": 
          const u =data;
          const user = { user_id: u.user_id, username: u.username, is_owner: !!u.is_owner};
          state.users.set(user.user_id, user); //ë©”ëª¨ë¦¬ ìƒíƒœ ê°±ì‹ 
          renderUserItem(user);
          break;
        case "user_left": 
          const uid = data.user_id;
          if (uid != null) {
            state.users.delete(uid);
            removeUserItem(uid);
          }
          break;

      case "owner_changed":
        for (const u of state.users.values()) {
          u.is_owner = (u.user_id === data.new_owner_id);
        }
        $online.innerHTML = "";
        for (const u of state.users.values()) renderUserItem(u);

        // ë‚´ê°€ ìƒˆ ë°©ì¥ì¸ì§€ í™•ì¸í•´ì„œ UI í† ê¸€
        const iAmNewOwner = (ME_ID != null && ME_ID === data.new_owner_id);
        setOwnerUI(iAmNewOwner);
        break;
  

        case "kicked":
          try{ localStorage.setItem('last_toast', JSON.stringify({level:'error', text:data.msg||'ê°•í‡´ë˜ì—ˆìŠµë‹ˆë‹¤.'})); }catch{}
          try{ ws.close(4403);}catch{}
          break;
        case "room_closed":
          try{ localStorage.setItem('last_toast', JSON.stringify({level:'warning', text:data.msg||'ë°©ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.'})); }catch{}
          try{ ws.close(4404);}catch{}
          break;
      }

      // action ê¸°ë°˜
      if (data.action === 'draw.stroke'){
        const { image_id, image_idx, path_id, points, color, size, mode, first, last } = data;
        const cur = imageState.list[imageState.idx];
        if (!cur) { warnD("recv stroke but no current image"); return; }

        const curKey = getImageKey(cur);
        const sameId = (curKey != null && image_id != null) && (String(curKey) === String(image_id));
        const sameIdx = (typeof image_idx === "number") && (image_idx === imageState.idx);
        if (!(EASY_MODE_IGNORE_IMAGE_ID || sameId || (EASY_MODE_INDEX_FALLBACK && sameIdx))) {
          warnD("drop stroke: image mismatch", { curKey, image_id, curIdx: imageState.idx, image_idx });
          return;
        }

        // ë””ë²„ê·¸ ë¡œê·¸
        groupD("recv draw.stroke", () => {
          logD({ first, last, path_id, image_id, image_idx, pts: points?.length ?? 0, mode, size, color });
        });

        ctx.lineCap='round';
        ctx.lineJoin='round';
        ctx.lineWidth=Number(size||4);
        if (mode==='pen'){ ctx.globalCompositeOperation='source-over'; ctx.strokeStyle=color||'#111'; }
        else { ctx.globalCompositeOperation='destination-out'; ctx.strokeStyle='rgba(0,0,0,1)'; }

        // í¬ì¸íŠ¸ ì—†ìœ¼ë©´ ì¢…ë£Œ ì‹ í˜¸ë§Œ ì²˜ë¦¬
        if (!Array.isArray(points) || points.length === 0) {
          if (last && path_id) remotePaths.delete(path_id);
          return;
        }

        // â”€â”€ í•µì‹¬ ë°©ì–´ ë¡œì§ â”€â”€
        // path_idê°€ ì—†ê±°ë‚˜ firstê°€ ëª…ì‹œì ìœ¼ë¡œ falseê°€ ì•„ë‹ˆë©´ "ì—°ê²° ê¸ˆì§€"
        const allowLink = !!path_id && (first === false);

        // path ìƒíƒœ
        let state = remotePaths.get(path_id) || { last: null, ts: 0 };

        // ì˜¤ë˜ëœ pathëŠ” ëŠê¸°(2ì´ˆ íƒ€ì„ì•„ì›ƒ)
        const now = Date.now();
        if (state.ts && now - state.ts > 2000) {
          state = { last: null, ts: now };
        }

        // í™”ë©´ ì¢Œí‘œë¡œ ë³€í™˜
        const toView = (pt) => fromNormalizedPoint(pt.x, pt.y);
        const vpts = points.map(toView);

        // ê·¸ë¦¬ê¸°
        ctx.beginPath();
        if (allowLink && state.last) {
          // ì´ì „ ì²­í¬ì™€ â€˜ê°™ì€ path_idâ€™ + â€˜first === falseâ€™ì¼ ë•Œë§Œ ì´ì–´ ê·¸ë¦¬ê¸°
          ctx.moveTo(state.last.x, state.last.y);
          for (let i=0;i<vpts.length;i++) ctx.lineTo(vpts[i].x, vpts[i].y);
        } else {
          // ìƒˆ ìŠ¤íŠ¸ë¡œí¬(ë˜ëŠ” path_id/first ì •ë³´ê°€ ë¶ˆì™„ì „): ë…ë¦½ì ìœ¼ë¡œ ê·¸ë¦°ë‹¤
          ctx.moveTo(vpts[0].x, vpts[0].y);
          for (let i=1;i<vpts.length;i++) ctx.lineTo(vpts[i].x, vpts[i].y);
          if (vpts.length === 1) ctx.lineTo(vpts[0].x + 0.001, vpts[0].y + 0.001);
        }
        ctx.stroke();

        // ìƒíƒœ ê°±ì‹ /ì •ë¦¬
        if (path_id) {
          state.last = vpts[vpts.length - 1];
          state.ts = now;
          if (last) remotePaths.delete(path_id);
          else remotePaths.set(path_id, state);
        }
        // path_idê°€ ì—†ìœ¼ë©´ ìƒíƒœë¥¼ ì €ì¥í•˜ì§€ ì•Šì•„ â€œë¶™ëŠ” ë¬¸ì œâ€ë¥¼ ì›ì²œ ì°¨ë‹¨
        return;
      }


      if (data.action === 'draw.clear'){
        const { image_id } = data;
        const cur = imageState.list[imageState.idx];
        const curKey = getImageKey(cur);
        logD("recv draw.clear", { image_id, curKey, idx: imageState.idx });
        if (cur && String(curKey) === String(image_id)){
          ctx.clearRect(0,0,$canvas.width,$canvas.height);
          cur.overlay = null;
        }
        return;
      }
      if (data.action === 'draw.snapshot') {
        const { image_id, strokes } = data;
        const cur = imageState.list[imageState.idx];
        logD("recv draw.snapshot", { image_id, curKey: getImageKey(cur), idx: imageState.idx, strokes: strokes?.length ?? 0 });
        if (!cur || String(getImageKey(cur)) !== String(image_id)) return;

        // ìŠ¤ëƒ…ìƒ·ì—ì„œë„ path_id ê¸°ì¤€ìœ¼ë¡œ ì´ì–´ ê·¸ë¦¬ê¸°(ë¼ì´ë¸Œ ìˆ˜ì‹ ê³¼ ë™ì¼í•œ ë³´ì •)
        ctx.clearRect(0, 0, $canvas.width, $canvas.height);
        const lastByPath = new Map(); // path_id -> {x,y}

        if (Array.isArray(strokes)) {
          for (const s of strokes) {
            const color = s.color || '#111';
            const size = s.size || 4;
            const mode = s.mode || 'pen';
            const pts = s.points || [];
            const pid = s.path_id || s.pid || null; // ì„œë²„ê°€ path_idë¥¼ ë‹¤ë¥´ê²Œ ë³´ë‚¼ ìˆ˜ë„ ìˆìŒ
            const first = !!s.first;

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = Number(size);
            if (mode === 'pen') { ctx.globalCompositeOperation = 'source-over'; ctx.strokeStyle = color; }
            else { ctx.globalCompositeOperation = 'destination-out'; ctx.strokeStyle = 'rgba(0,0,0,1)'; }

            if (!pts.length) continue;

            const vpts = pts.map(p => fromNormalizedPoint(p.x, p.y));

            ctx.beginPath();
            const prev = pid ? lastByPath.get(pid) : null;

            if (prev && !first) {
              // ì´ì „ ì²­í¬ì˜ ë§ˆì§€ë§‰ ì ì—ì„œ ì´ì–´ì„œ ê·¸ë¦¬ê¸°
              ctx.moveTo(prev.x, prev.y);
              for (let i = 0; i < vpts.length; i++) {
                ctx.lineTo(vpts[i].x, vpts[i].y);
              }
            } else {
              // ìƒˆ ìŠ¤íŠ¸ë¡œí¬(í˜¹ì€ path_id ì •ë³´ê°€ ì—†ì„ ë•ŒëŠ” ì²­í¬ ë‹¨ìœ„ë¡œ ê·¸ë¦¼)
              ctx.moveTo(vpts[0].x, vpts[0].y);
              for (let i = 1; i < vpts.length; i++) {
                ctx.lineTo(vpts[i].x, vpts[i].y);
              }
              if (vpts.length === 1) {
                ctx.lineTo(vpts[0].x + 0.001, vpts[0].y + 0.001);
              }
            }

            ctx.stroke();

            // ë§ˆì§€ë§‰ ì  ì €ì¥(ë‹¤ìŒ ì²­í¬ ì—°ê²°ìš©)
            if (pid) lastByPath.set(pid, vpts[vpts.length - 1]);
          }
        }
        return;
      }

      if (data.action === 'image.goto'){
        persistOverlayForCurrentImage();
        if (typeof data.idx === 'number'){
          imageState.idx = Math.max(0, Math.min(imageState.list.length-1, data.idx));
        } else if (data.image_id != null){
          const i=imageState.list.findIndex(x=>getImageKey(x)===data.image_id);
          if (i>=0) imageState.idx=i;
        }
        renderImageViewer();
        return;
      }

      // ìŠ¹ì¸ í”Œë¡œìš°
      if (data.action === 'image.propose' && I_AM_OWNER){
        const { pending_id, uploader_id, uploader_name, name, size, type } = data;
        pendingQueue.set(pending_id, { uploader_id, uploader_name, name, size, type });
        renderPending();
        return;
      }
      if (data.action === 'image.approved'){
        const { pending_id, uploader_id } = data;
        if (I_AM_OWNER){ pendingQueue.delete(pending_id); renderPending(); }
        if (ME_ID === uploader_id){
          const file = localPendingFiles.get(pending_id);
          if (file){
            const fd = new FormData(); fd.append('images', file);
            fetch(`{% url 'api_image_upload' room.slug %}`, { method:'POST', headers:{'X-CSRFToken':csrftoken}, body:fd })
              .then(r=>r.json())
              .then(j=>{
                if (j?.results?.length){
                  for (const it of j.results){
                    pushImageMessage({ id: it.image_id || it.id || it.message_id || it.image_url || null, image_id:it.image_id, message_id:it.message_id, user:'me', image_url: it.image_url, ts: it.ts||new Date().toISOString() }, true);
                  }
                }
                localPendingFiles.delete(pending_id);
                showToast('success','ì´ë¯¸ì§€ ì—…ë¡œë“œê°€ ìŠ¹ì¸ë˜ì–´ ê²Œì‹œë˜ì—ˆìŠµë‹ˆë‹¤.');
              }).catch(()=>showToast('error','ì—…ë¡œë“œ ì‹¤íŒ¨'));
          }
        }
        return;
      }
      if (data.action === 'image.rejected'){
        const { pending_id, uploader_id } = data;
        if (I_AM_OWNER){ pendingQueue.delete(pending_id); renderPending(); }
        if (ME_ID === uploader_id){ localPendingFiles.delete(pending_id); showToast('warning','ì´ë¯¸ì§€ ì—…ë¡œë“œê°€ ê±°ì ˆë˜ì—ˆìŠµë‹ˆë‹¤.'); }
        return;
      }
      if (data.action === 'image.deleted') {
        const { message_id } = data;
        appendChat({ user: 'system', message: '[ì´ë¯¸ì§€ ì‚­ì œë¨]', ts: data.ts }); 
        removeImageByMessageId(message_id);
        return;
      }

    };
    ws.onclose = (e)=>{
      warnD("ws close", {code: e.code, reason: e.reason, wasClean: e.wasClean});
      const no_reenter=[4000,4001,4403,4404];
      if (no_reenter.includes(e.code)){ location.href = HOME_URL; return; }
      setTimeout(connect, 1000);
    };
  }
  connect();

  // ì´ë¯¸ì§€ ì¸ë±ìŠ¤ ì´ë™ + ë°©ì†¡
  function gotoIndex(idx){
    if (idx<0 || idx>=imageState.list.length) return;
    imageState.idx = idx; renderImageViewer();
  }
  $imgPrev.addEventListener('click', ()=>{
    if (imageState.list.length===0) return;
    persistOverlayForCurrentImage();
    const nextIdx = Math.max(0, imageState.idx-1);
    gotoIndex(nextIdx);
    const img = imageState.list[nextIdx];
    if (ws?.readyState===1) ws.send(JSON.stringify({ action:'image.goto', idx:nextIdx, image_id:String(getImageKey(img)), ts:Date.now() }));
  });
  $imgNext.addEventListener('click', ()=>{
    if (imageState.list.length===0) return;
    persistOverlayForCurrentImage();
    const nextIdx = Math.min(imageState.list.length-1, imageState.idx+1);
    gotoIndex(nextIdx);
    const img = imageState.list[nextIdx];
    if (ws?.readyState===1) ws.send(JSON.stringify({ action:'image.goto', idx:nextIdx, image_id:String(getImageKey(img)), ts:Date.now() }));
  });

  // ì±„íŒ… ì „ì†¡
  $chatForm?.addEventListener('submit', e=>{
    e.preventDefault();
    const text = ($chatInput?.value||'').trim();
    if (!text || !ws || ws.readyState!==1) return;
    ws.send(JSON.stringify({ action:'chat', message:text, ts:Date.now() }));
    $chatInput.value=''; $chatLog.scrollTop=$chatLog.scrollHeight;
  });

  // ì—…ë¡œë“œ: ì œì•ˆâ†’(ë°©ì¥ ìŠ¹ì¸ í›„) ì‹¤ì œ ì—…ë¡œë“œ
  $uploadForm?.addEventListener('submit', async (e)=>{
    e.preventDefault();
    const files = $imageInput?.files;
    if (!files?.length) return;

    for (const f of files){
      const pendingId = `${ME_ID||'anon'}_${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
      localPendingFiles.set(pendingId, f); // ì—…ë¡œë”ë§Œ ë¡œì»¬ ë³´ê´€
      if (ws?.readyState===1){
        ws.send(JSON.stringify({ action:'image.propose', pending_id: pendingId, name:f.name, size:f.size, type:f.type, ts:Date.now() }));
      }
    }
    $imageInput.value='';
    showToast('info','ë°©ì¥ ìŠ¹ì¸ ëŒ€ê¸° ì¤‘â€¦');
  });

  // ë°©ì¥: ëŒ€ê¸° ë Œë”
  function renderPending(){
    if (!I_AM_OWNER) return;
    const $panel = document.getElementById('pending-panel');
    const $list  = document.getElementById('pending-list');
    const $empty = document.getElementById('pending-empty');
    $list.innerHTML='';
    if (pendingQueue.size===0){ show($empty); return; }
    $empty.style.display='none';
    for (const [pid,item] of pendingQueue.entries()){
      const row = el('li',{class:'online__item'},
        el('div',{},
          el('div',{class:'text-sm font-semibold'}, item.name||'(ì´ë¦„ ì—†ìŒ)'),
          el('div',{class:'text-xs text-gray-500'}, `${item.uploader_name||'user'} Â· ${fmtBytes(item.size)} Â· ${item.type||''}`)
        )
      );
      const okBtn = el('button',{class:'px-2 py-1 text-sm border rounded'},'ìŠ¹ì¸');
      const noBtn = el('button',{class:'px-2 py-1 text-sm border rounded ml-2'},'ê±°ì ˆ');
      okBtn.addEventListener('click', ()=>{ if(ws?.readyState===1){ ws.send(JSON.stringify({ action:'image.approved', pending_id:pid, uploader_id:item.uploader_id, ts:Date.now() })); }});
      noBtn.addEventListener('click', ()=>{ if(ws?.readyState===1){ ws.send(JSON.stringify({ action:'image.rejected', pending_id:pid, uploader_id:item.uploader_id, ts:Date.now() })); }});
      const btns = el('div',{}); btns.appendChild(okBtn); btns.appendChild(noBtn);
      row.appendChild(btns); $list.appendChild(row);
    }
  }
  function removeImageByMessageId(messageId) {
    const rmIdx = imageState.list.findIndex(it =>
      String(it.message_id || it.id || '') === String(messageId)
    );
    if (rmIdx < 0) return false;

    imageState.list.splice(rmIdx, 1); // ëª©ë¡ì—ì„œ ì œê±°

    if (imageState.list.length === 0) { // ë¹ˆëª©ë¡ì´ë©´ ì´ˆê¸°í™”
      imageState.idx = -1;
      ctx.clearRect(0,0,$canvas.width,$canvas.height);
      renderImageViewer();
      return true;
    }

    if (rmIdx <= imageState.idx) { //ì´ë¯¸ì§€ì˜ ê°œìˆ˜ê°€ ì¤„ì—ˆìœ¼ë¯€ë¡œ ì¸ë±ìŠ¤ ì¡°ì •
      imageState.idx = Math.max(0, imageState.idx - 1);
    }

    ctx.clearRect(0,0,$canvas.width,$canvas.height);
    renderImageViewer();
    return true;
  }
  if($del_btn) {
    $del_btn.addEventListener('click', async () => {
      if (imageState.idx < 0 || imageState.list.length === 0) {
        showToast('warning', 'ì‚­ì œí•  ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }
      const cur = imageState.list[imageState.idx];
      const messageId = cur.message_id || cur.id;
      if (!messageId) {
        showToast('error', 'ì´ ì´ë¯¸ì§€ì˜ IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }
      if (!confirm('ì´ ì´ë¯¸ì§€ë¥¼ ì‚­ì œí• ê¹Œìš”?')) return;

      try {
        const res = await fetch(`/rooms/${slug}/images/${messageId}/delete/`, {
          method: 'POST',
          headers: { 'X-CSRFToken': csrftoken },
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data.ok) {
          const msg = (data && data.error) || (res.status === 403 ? 'ì‚­ì œ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.' : 'ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
          showToast('error', msg);
          return;
        }
        // ì„œë²„ê°€ image.deleted ë¸Œë¡œë“œìºìŠ¤íŠ¸ë¥¼ ë³´ëƒ„. ë‚™ê´€ì  UI ì›í•˜ë©´ ì•„ë˜ í•œ ì¤„ ì£¼ì„ í•´ì œ
        // removeImageByMessageId(messageId);
        showToast('success', 'ì´ë¯¸ì§€ë¥¼ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.');
      } catch {
        showToast('error', 'ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ë¡œ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      }
    });
  }

  // ì´ˆê¸° ë Œë”
  renderImageViewer();

  const $leaveForm = document.getElementById('room-leave');
  $leaveForm?.addEventListener('submit', function (e) {
    e.preventDefault();
    try { ws && ws.readyState === 1 && ws.send(JSON.stringify({ action: "leave" })); } catch {}
    setTimeout(() => e.target.submit(), 150);
  });

  function setOwnerUI(isOwner){
    I_AM_OWNER = !!isOwner;
    document.querySelectorAll('.owner-only').forEach(el => {
      el.style.display = isOwner ? '' : 'none';
    });
  }
  setOwnerUI(!!I_AM_OWNER);

})();


// í† ìŠ¤íŠ¸
function showToast(level, text){
  const area=document.getElementById('toast-area'); if(!area) return;
  const cl = level==='success'?'is-ok': level==='warning'?'is-warn': level==='error'?'is-bad':'is-info';
  const icon = level==='success'?'âœ…': level==='warning'?'âš ï¸': level==='error'?'â›”':'â„¹ï¸';
  const div=document.createElement('div');
  div.className=`toast__item ${cl}`; div.setAttribute('role','alert');
  div.innerHTML=`<span class="toast__icon">${icon}</span>
                 <div class="toast__msg">${text}</div>
                 <button type="button" class="toast__close" onclick="this.parentElement.remove()">âœ•</button>`;
  area.appendChild(div);
}
</script>

{% endblock %}
